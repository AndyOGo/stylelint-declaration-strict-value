{"version":3,"file":"index.modern.js","sources":["../src/defaults.ts","../src/lib/validation.ts","../src/index.ts"],"sourcesContent":["import type { Node, Root } from 'postcss';\n\n/**\n * A hash of CSS properties to ignore variables or functions.\n */\nexport interface IIgnoreVariableOrFunctionHash {\n  [key: string]: boolean;\n}\n/**\n * Possible config for `ignoreVariables` and `ignoreFunctions` option.\n */\nexport type TIgnoreVariableOrFunctionConfig =\n  | boolean\n  | IIgnoreVariableOrFunctionHash;\n/**\n * A Regular Expression string to match a CSS property or value.\n */\nexport type TRegExpString = string;\n/**\n * A CSS value to be ignored.\n */\nexport type TIgnoreValue = number | string | TRegExpString;\n/**\n * A list of CSS values to be ignored.\n */\nexport type TIgnoreValueList = Array<TIgnoreValue>;\n/**\n * A hash of CSS properties with ignored values.\n * - `''` key applies to all configured CSS properties.\n * - key can also be Regular Expression string.\n */\nexport interface IIgnoreValueHash {\n  '': TIgnoreValue | TIgnoreValueList;\n  [CSSPropertyName: string]: TIgnoreValue | TIgnoreValueList;\n  // [CSSPropertyName: TRegExpString]: TIgnoreValue | TIgnoreValueList;\n}\n/**\n * @internal\n */\nexport const isIIgnoreValueHash = (\n  key: unknown,\n  value: unknown\n): key is IIgnoreValueHash =>\n  typeof key === 'object' && Object.hasOwnProperty.call(key, value);\n/**\n * Possible config for `ignoreValues` and ~~`ignoreKeywords`~~ option.\n */\nexport type TIgnoreValueConfig =\n  | null\n  | TIgnoreValue\n  | TIgnoreValueList\n  | IIgnoreValueHash;\n/**\n * Result of CSS value validation.\n */\nexport interface IDeclarationStrictValueResult {\n  /**\n   * Whether or not variable is valid.\n   */\n  validVar: boolean;\n\n  /**\n   * Whether or not function is valid.\n   */\n  validFunc: boolean;\n\n  /**\n   * Whether or not keyword is valid.\n   */\n  validKeyword: boolean;\n\n  /**\n   * Whether or not value is valid.\n   */\n  validValue: boolean;\n\n  /**\n   * Longhand CSS Property, if expanded.\n   */\n  longhandProp?: string;\n\n  /**\n   * Longhand CSS value, if expanded.\n   */\n  longhandValue?: string;\n}\n/**\n * A autofix function.\n */\nexport type TAutoFixFunc = (\n  node: Node,\n  result: IDeclarationStrictValueResult,\n  root: Root,\n  config: ISecondaryOptions\n) => string;\n/**\n * Path to autofix function module.\n */\nexport type TAutoFixModule = string;\n/**\n * Possible config for `autoFixFunc` option.\n */\nexport type TAutoFixFuncConfig =\n  | null\n  | undefined\n  | TAutoFixModule\n  | TAutoFixFunc;\n\n/**\n * Plugin secondary options.\n */\nexport interface ISecondaryOptions {\n  /**\n   * Whether or not to ignore variables.\n   *\n   * @defaultValue true\n   */\n  ignoreVariables?: TIgnoreVariableOrFunctionConfig;\n\n  /**\n   * Whether or not to ignore function.\n   *\n   * @defaultValue true\n   */\n  ignoreFunctions?: TIgnoreVariableOrFunctionConfig;\n\n  /**\n   * An ignored keywords config.\n   *\n   * @defaultValue null\n   * @deprecated use `ignoreValues` option.\n   */\n  ignoreKeywords?: TIgnoreValueConfig;\n\n  /**\n   * An ignored values config.\n   *\n   * @defaultValue null\n   */\n  ignoreValues?: TIgnoreValueConfig;\n\n  /**\n   * Whether or not to expand shorthand CSS properties.\n   *\n   * @defaultValue false\n   */\n  expandShorthand?: boolean;\n\n  /**\n   * Whether or not to expand longhand CSS properties recursivly - this is only useful for the `border` property.\n   *\n   * @defaultValue false\n   */\n  recurseLonghand?: boolean;\n\n  /**\n   * Adjust severity of the rule, `'warning'` or `'error'` (default).\n   *\n   * @defaultValue 'error'\n   */\n  severity?: string;\n\n  /**\n   * A custom message when a rule is violated, interpolated with `${types}`, `${value}` and `${property}`.\n   *\n   * @defaultValue undefined\n   */\n  message?: string;\n\n  /**\n   * Don't auto-fix if `--fix` option is applied.\n   *\n   * @defaultValue false\n   */\n  disableFix?: boolean;\n\n  /**\n   * By default no auto-fix feature.\n   *\n   * @defaultValue null\n   */\n  autoFixFunc?: TAutoFixFuncConfig;\n}\n\nconst defaults: ISecondaryOptions = {\n  ignoreVariables: true,\n  ignoreFunctions: true,\n  ignoreKeywords: null,\n  ignoreValues: null,\n  expandShorthand: false,\n  recurseLonghand: false,\n  severity: 'error',\n  message: undefined,\n  disableFix: false,\n  autoFixFunc: null,\n};\n\nexport default defaults;\n","import path from 'path';\n\nimport defaults, {\n  ISecondaryOptions,\n  TIgnoreValue,\n  TIgnoreValueList,\n  IIgnoreValueHash,\n  TIgnoreVariableOrFunctionConfig,\n  IIgnoreVariableOrFunctionHash,\n  TIgnoreValueConfig,\n  TAutoFixFunc,\n  TAutoFixFuncConfig,\n  isIIgnoreValueHash,\n} from '../defaults';\n\n/**\n * Check if type is either `number` or `string`.\n *\n * @internal\n * @param value - Any value.\n *\n * @returns Returns `true` if `value`'s type is either `number` or `string`, else `false`.\n */\nfunction isNumberOrString(value: unknown): value is TIgnoreValue {\n  const type = typeof value;\n\n  return type === 'string' || type === 'number';\n}\n\n/**\n * Validate primary options of stylelint plugin config.\n *\n * @internal\n * @param actual - The actual config to validate.\n *\n * @returns Returns `true` if primary options are valid, else `false`.\n */\nexport function validProperties(\n  actual: unknown\n): actual is TIgnoreValue | TIgnoreValueList {\n  return (\n    isNumberOrString(actual) ||\n    (Array.isArray(actual) && actual.every((item) => isNumberOrString(item)))\n  );\n}\n\n/**\n * Validate optional hash keyword config.\n *\n * @internal\n * @param actual - A keyword config.\n *\n * @returns Returns `true` if hash keyword config is valid, else `false`.\n */\nfunction validHash(actual: unknown): actual is IIgnoreValueHash {\n  if (typeof actual !== 'object' || !actual) return false;\n\n  return Object.keys(actual).every((key) =>\n    validProperties((actual as IIgnoreValueHash)[key as keyof IIgnoreValueHash])\n  );\n}\n\n/**\n * Validate optional boolean hash variable/function config.\n *\n * @internal\n * @param actual - A variable/function config.\n *\n * @returns Returns `true` if hash variable/function config is valid, else `false`.\n */\nfunction validBooleanHash(\n  actual: unknown\n): actual is IIgnoreVariableOrFunctionHash {\n  if (typeof actual !== 'object' || !actual) return false;\n\n  return Object.keys(actual).every(\n    (key) =>\n      typeof (actual as IIgnoreVariableOrFunctionHash)[\n        key as keyof IIgnoreVariableOrFunctionHash\n      ] === 'boolean'\n  );\n}\n\n/**\n * Validate optional secondary options of stylelint plugin config.\n *\n * @internal\n * @param actual - The actual config to validate.\n *\n * @returns Returns `true` if secondary options are valied, else `false`.\n */\nexport function validOptions(actual: ISecondaryOptions): boolean {\n  if (typeof actual !== 'object') return false;\n\n  const allowedKeys = Object.keys(defaults);\n  if (!Object.keys(actual).every((key) => allowedKeys.indexOf(key) > -1))\n    return false;\n\n  if (\n    'ignoreVariables' in actual &&\n    typeof actual.ignoreVariables !== 'boolean' &&\n    !validBooleanHash(actual.ignoreVariables) &&\n    actual.ignoreVariables !== null\n  )\n    return false;\n\n  if (\n    'ignoreFunctions' in actual &&\n    typeof actual.ignoreFunctions !== 'boolean' &&\n    !validBooleanHash(actual.ignoreFunctions) &&\n    actual.ignoreFunctions !== null\n  )\n    return false;\n\n  if (\n    'severity' in actual &&\n    typeof actual.severity !== 'string' &&\n    actual.severity !== null\n  )\n    return false;\n\n  if (\n    'ignoreKeywords' in actual &&\n    !validProperties(actual.ignoreKeywords) &&\n    !validHash(actual.ignoreKeywords)\n  )\n    return false;\n\n  if (\n    'ignoreValues' in actual &&\n    !validProperties(actual.ignoreValues) &&\n    !validHash(actual.ignoreValues)\n  )\n    return false;\n\n  if (\n    'expandShorthand' in actual &&\n    typeof actual.expandShorthand !== 'boolean' &&\n    actual.expandShorthand !== null\n  )\n    return false;\n\n  if (\n    'recurseLonghand' in actual &&\n    typeof actual.recurseLonghand !== 'boolean' &&\n    actual.recurseLonghand !== null\n  )\n    return false;\n\n  if (\n    'message' in actual &&\n    typeof actual.message !== 'string' &&\n    actual.message !== null\n  )\n    return false;\n\n  if (\n    'disableFix' in actual &&\n    typeof actual.disableFix !== 'boolean' &&\n    actual.disableFix !== null\n  )\n    return false;\n\n  if (\n    'autoFixFunc' in actual &&\n    typeof actual.autoFixFunc !== 'function' &&\n    typeof actual.autoFixFunc !== 'string' &&\n    actual.autoFixFunc !== null\n  )\n    return false;\n\n  return true;\n}\n\n/**\n * @internal\n */\ntype TExpectedType = 'variable' | 'function' | 'keyword';\n/**\n * @internal\n */\ntype TExpectedTypes = Array<TExpectedType>;\n\n/**\n * Build expected message for stylelint report.\n *\n * @internal\n * @param types - Either `variable`, `function` and/or `keyword`.\n * @param value - The CSS declaration's value.\n * @param property - The CSS declaration's property.\n * @param customMessage - A custom message to be delivered upon error interpolated with `${types}`, `${value}` and `${property}`.\n *\n * @returns Returns an expected message for stylelint report.\n */\nexport function expected(\n  types: TExpectedType | TExpectedTypes,\n  value: string,\n  property: string,\n  customMessage = ''\n): string {\n  let typesMessage: string;\n\n  if (Array.isArray(types)) {\n    const typesLast = types.pop();\n\n    // eslint-disable-next-line no-param-reassign\n    typesMessage = types.length\n      ? `${types.join(', ')} or ${typesLast}`\n      : (typesLast as string);\n  } else {\n    typesMessage = types;\n  }\n\n  if (typeof customMessage === 'string' && customMessage.length) {\n    /* eslint-disable no-template-curly-in-string */\n    return customMessage\n      .replace('${types}', typesMessage)\n      .replace('${value}', value)\n      .replace('${property}', property);\n    /* eslint-enable no-template-curly-in-string */\n  }\n\n  return `Expected ${typesMessage} for \"${value}\" of \"${property}\"`;\n}\n\n/**\n * Get configured types for stylelint report message.\n *\n * @internal\n * @param config - The secondary stylelint-plugin config.\n * @param property - The specific CSS declaration's property of the current iteration.\n *\n * @returns Returns a list of configured types.\n */\nexport function getTypes(\n  config: ISecondaryOptions,\n  property: string\n): TExpectedTypes {\n  const {\n    ignoreVariables,\n    ignoreFunctions,\n    ignoreKeywords,\n    ignoreValues,\n  } = config;\n  const types: TExpectedTypes = [];\n\n  if (ignoreVariables) {\n    types.push('variable');\n  }\n\n  if (ignoreFunctions) {\n    types.push('function');\n  }\n\n  if (ignoreKeywords && getIgnoredKeywords(ignoreKeywords, property)) {\n    types.push('keyword');\n  }\n\n  if (ignoreValues && getIgnoredValues(ignoreValues, property)) {\n    types.push('keyword');\n  }\n\n  return types;\n}\n\n/**\n * Get the correct ignored variable or function for a specific CSS declaration's property\n * out of a complex `ignoreVariablesOrFunctions` config hash or boolean.\n *\n * @internal\n * @param ignoreVariablesOrFunctions - The variables or functions to ignore.\n * @param property - The specific CSS declaration's property of the current iteration.\n *\n * @returns Returns ignored variable or function for a specific CSS property.\n */\nexport function getIgnoredVariablesOrFunctions(\n  ignoreVariablesOrFunctions: TIgnoreVariableOrFunctionConfig,\n  property: string\n): boolean {\n  // @see: https://github.com/microsoft/TypeScript/issues/41627\n  // const type = typeof ignoreVariablesOrFunctions\n\n  if (typeof ignoreVariablesOrFunctions === 'boolean') {\n    return ignoreVariablesOrFunctions;\n  }\n\n  if (\n    typeof ignoreVariablesOrFunctions === 'object' &&\n    ignoreVariablesOrFunctions &&\n    {}.hasOwnProperty.call(ignoreVariablesOrFunctions, property)\n  ) {\n    return ignoreVariablesOrFunctions[property];\n  }\n\n  return !!ignoreVariablesOrFunctions;\n}\n\n/**\n * Get the correct ignored keywords for a specific CSS declaration's property\n * out of a complex `ignoreKeywords` config hash or array.\n *\n * @internal\n * @param ignoreKeywords - The keyword/-s to ignore.\n * @param property - The specific CSS declaration's property of the current iteration.\n *\n * @returns Returns ignored keywords for a specific CSS property, or `null`.\n */\nexport function getIgnoredKeywords(\n  ignoreKeywords: TIgnoreValueConfig,\n  property: string\n): null | TIgnoreValueList {\n  if (!ignoreKeywords) return null;\n\n  let keywords = ignoreKeywords;\n\n  if (isIIgnoreValueHash(keywords, property)) {\n    keywords = keywords[property];\n  } else if (isIIgnoreValueHash(keywords, '')) {\n    keywords = keywords[''];\n  }\n\n  return Array.isArray(keywords) ? keywords : [keywords];\n}\n\n/**\n * Get the correct ignored values for a specific CSS declaration's property\n * out of a complex `ignoreValues` config hash or array.\n *\n * @internal\n * @param ignoreValues - The values/-s to ignore.\n * @param property - The specific CSS declaration's property of the current iteration.\n * @returns Returns ignored values for a specific CSS property, or `null`.\n */\nexport function getIgnoredValues(\n  ignoreValues: TIgnoreValueConfig,\n  property: string\n): null | TIgnoreValueList {\n  if (!ignoreValues) return null;\n\n  let values = ignoreValues;\n\n  if (isIIgnoreValueHash(values, property)) {\n    values = values[property];\n  } else if (isIIgnoreValueHash(values, '')) {\n    values = values[''];\n  }\n\n  return Array.isArray(values) ? values : [values];\n}\n\n/**\n * Get the auto-fix function either by a function directly or from source file.\n *\n * @internal\n * @param autoFixFunc - A JavaScript function or a module path to resolve it, also from cwd.\n *\n * @returns Returns the auto-fix function if found, else `null`.\n */\nexport function getAutoFixFunc(\n  autoFixFunc: TAutoFixFuncConfig\n): null | TAutoFixFunc {\n  // @see: https://github.com/microsoft/TypeScript/issues/41627\n  // const type = typeof autoFixFunc\n\n  if (typeof autoFixFunc === 'function') {\n    return autoFixFunc;\n  }\n\n  if (typeof autoFixFunc === 'string') {\n    let resolveAutoFixfunc;\n\n    try {\n      resolveAutoFixfunc = require.resolve(autoFixFunc);\n    } catch (error) {\n      resolveAutoFixfunc = require.resolve(\n        path.join(process.cwd(), autoFixFunc)\n      );\n    }\n\n    // eslint-disable-next-line import/no-dynamic-require, global-require\n    return require(resolveAutoFixfunc);\n  }\n\n  return null;\n}\n","import type { Declaration, Root, Result, AtRule } from 'postcss';\nimport stylelint from 'stylelint';\nimport shortCSS from 'shortcss';\nimport list from 'shortcss/lib/list';\nimport cssValues from 'css-values';\n\nimport {\n  validProperties,\n  validOptions,\n  expected,\n  getTypes,\n  getIgnoredVariablesOrFunctions,\n  getIgnoredKeywords,\n  getIgnoredValues,\n  getAutoFixFunc,\n} from './lib/validation';\nimport defaults, {\n  ISecondaryOptions,\n  TIgnoreValue,\n  TRegExpString,\n} from './defaults';\n\n/**\n * Rule Name.\n */\nconst ruleName = 'scale-unlimited/declaration-strict-value';\nconst { utils } = stylelint;\nconst messages = utils.ruleMessages(ruleName, {\n  expected,\n});\n/**\n * RegExp to skip non-CSS properties.\n *\n * @internal\n */\nconst reSkipProp = /^(?:@|\\$|--).+$/;\n/**\n * RegExp to parse CSS, SCSS and less variables.\n * - allowing CSS variables to be multi line\n * - Sass namespaces and CSS <ident-token> supported\n *\n * @internal\n * @see https://github.com/sass/sass/blob/master/accepted/module-system.md#member-references\n * @see  https://drafts.csswg.org/css-syntax-3/#ident-token-diagram\n */\n// eslint-disable-next-line no-control-regex\nconst reVar = /^-?(?:@.+|(?:(?:[a-zA-Z_-]|[^\\x00-\\x7F])+(?:[a-zA-Z0-9_-]|[^\\x00-\\x7F])*\\.)?\\$.+|var\\(\\s*--[\\s\\S]+\\))$/;\n/**\n * RegExp to parse functions.\n * - irgnoring CSS variables `var(--*)`\n * - allow multi line arguments\n *\n * @internal\n */\nconst reFunc = /^(?!var\\(\\s*--)[\\s\\S]+\\([\\s\\S]*\\)$/;\n/**\n * RegExp to parse regular expressions.\n * - supporting patterns\n * - and optional flags\n *\n * @internal\n */\nconst reRegex = /^\\/(.*)\\/([a-zA-Z]*)$/;\n/**\n * @internal\n */\ntype TRegExpArray = [string, string?];\n/**\n * Checks if string is a Regular Expression.\n *\n * @internal\n * @param value - Any string.\n */\nconst isRegexString = (value: string): value is TRegExpString =>\n  reRegex.test(value);\n/**\n * Get pattern and flags of a Regular Expression string.\n *\n * @internal\n * @param value - Any string representing a Regular Expression.\n * @returns An Array of pattern and flags of a Regular Expression string.\n */\nconst getRegexString = (value: string): TRegExpArray =>\n  value.match(reRegex)!.slice(1) as TRegExpArray;\n/**\n * Convert a Regular Expression string to an RegExp object.\n *\n * @internal\n * @param value - Any string representing a Regular Expression.\n * @returns A Regular Expression object.\n */\nconst stringToRegex = (value: TRegExpString) => {\n  const [pattern, flags] = getRegexString(value);\n  return new RegExp(pattern, flags);\n};\n/**\n * Map ignored value config to a Regular expression.\n *\n * @internal\n * @param ignoreValue - A ignored value property.\n * @returns A Regular Expression to match ignored values.\n */\nconst mapIgnoreValue = (ignoreValue: TIgnoreValue) =>\n  isRegexString(`${ignoreValue}`)\n    ? stringToRegex(`${ignoreValue}`)\n    : new RegExp(`^${ignoreValue}$`);\n\n/**\n * A rule function essentially returns a little PostCSS plugin.\n * It will report violations of this rule.\n *\n * @param root - PostCSS root (the parsed AST).\n * @param result - PostCSS lazy result.\n */\ntype PostCSSPlugin = (root: Root, result: Result) => void | PromiseLike<void>;\n\n/**\n * Third Stylelint plugin context parameter.\n */\ninterface StylelintContext {\n  /**\n   * Wheter or not stylelint was executed with `--fix` option.\n   *\n   * @defaultValue false\n   */\n  fix?: boolean;\n}\n\n/**\n * Primary options, a CSS property or list of CSS properties to lint.\n * - Regular Expression strings are supported\n */\ntype TPrimaryOptions = string | TRegExpString | TPrimaryOptions[];\n\n/**\n * Stylelint declaration strict value rule function.\n *\n * @see https://stylelint.io/developer-guide/plugins\n * @param properties - Primary options, a CSS property or list of CSS properties to lint.\n * @param options- Secondary options, configure edge cases.\n * @param context - Only used for autofixing.\n *\n * @returns Returns a PostCSS Plugin.\n */\ninterface StylelintRuleFunction {\n  (\n    primaryOption: TPrimaryOptions,\n    secondaryOptions?: ISecondaryOptions,\n    context?: StylelintContext\n  ): PostCSSPlugin;\n  primaryOptionArray: boolean;\n}\nconst ruleFunction: StylelintRuleFunction = (\n  properties: string | string[],\n  options: ISecondaryOptions,\n  context: StylelintContext = {}\n) => (root: Root, result: Result) => {\n  // validate stylelint plugin options\n  const hasValidOptions = utils.validateOptions(\n    result,\n    ruleName,\n    {\n      actual: properties,\n      possible: validProperties,\n    },\n    {\n      actual: options,\n      possible: validOptions,\n      optional: true,\n    }\n  );\n\n  if (!hasValidOptions) return;\n\n  // normalize options\n  if (!Array.isArray(properties)) {\n    // eslint-disable-next-line no-param-reassign\n    properties = [properties];\n  }\n\n  const config: ISecondaryOptions = {\n    ...defaults,\n    ...options,\n  };\n  const {\n    ignoreVariables,\n    ignoreFunctions,\n    ignoreKeywords,\n    ignoreValues,\n    message,\n    disableFix,\n    autoFixFunc,\n    expandShorthand,\n    recurseLonghand,\n  } = config;\n  const autoFixFuncNormalized = getAutoFixFunc(autoFixFunc);\n  interface IRegExpMap {\n    [key: string]: RegExp;\n  }\n  type TRegExpMap = null | IRegExpMap;\n  interface IRegExpList {\n    [key: string]: RegExp[];\n  }\n  type TRegExpList = null | IRegExpList;\n  const reKeywords: TRegExpMap = ignoreKeywords ? {} : null;\n  const reValues: TRegExpList = ignoreValues ? {} : null;\n  let cssLoaderValues: RegExp;\n\n  if (ignoreVariables) {\n    const cssLoaderValuesNames: string[] = [];\n    root.walkAtRules('value', (rule: AtRule) => {\n      const { params } = rule;\n      const name = params.split(':')[0].trim();\n\n      cssLoaderValuesNames.push(name);\n    });\n\n    cssLoaderValues = new RegExp(`^-?(:?${cssLoaderValuesNames.join('|')})$`);\n  }\n\n  // loop through all properties\n  properties.forEach((property) => {\n    let propFilter: string | RegExp = property;\n\n    // parse RegExp\n    if (isRegexString(propFilter)) {\n      propFilter = stringToRegex(propFilter);\n    }\n\n    // walk through all declarations filtered by configured properties\n    root.walkDecls(filterDecl);\n\n    /**\n     * Filter declarations for matching properties and expand shorthand properties.\n     *\n     * @internal\n     * @param node - A Declaration-Node from PostCSS AST-Parser.\n     */\n    function filterDecl(node: Declaration) {\n      const { value, prop } = node;\n\n      // skip variable declarations\n      if (reSkipProp.test(prop)) return;\n\n      const isShortHand = expandShorthand && shortCSS.isShorthand(prop);\n\n      if (\n        prop === propFilter ||\n        (!isShortHand && propFilter instanceof RegExp && propFilter.test(prop))\n      ) {\n        const values: string[] = list.space(value);\n\n        // handle multi-value props, like scrollbar-color\n        if (values.length > 1) {\n          let failedFlag = false;\n\n          values.forEach((valueItem) => {\n            if (!failedFlag) {\n              failedFlag = lintDeclStrictValue(node, prop, valueItem);\n            }\n          });\n        } else {\n          lintDeclStrictValue(node);\n        }\n      } else if (isShortHand) {\n        const expandedProps = shortCSS.expand(prop, value, recurseLonghand);\n        let failedFlag = false;\n\n        Object.keys(expandedProps).forEach((longhandProp) => {\n          const longhandValue = expandedProps[longhandProp];\n\n          if (\n            !failedFlag &&\n            (longhandProp === propFilter ||\n              (propFilter instanceof RegExp && propFilter.test(longhandProp)))\n          ) {\n            failedFlag = lintDeclStrictValue(\n              node,\n              longhandProp,\n              longhandValue,\n              true\n            );\n          }\n        });\n      }\n    }\n\n    /**\n     * Lint usages of declarations values against, variables, functions\n     * or custom keywords - as configured.\n     *\n     * @internal\n     * @param node - A Declaration-Node from PostCSS AST-Parser.\n     * @param longhandProp - A Declaration-Node from PostCSS AST-Parser.\n     * @param longhandValue - A Declaration-Node from PostCSS AST-Parser.\n     * @param isExpanded - Whether or not this declaration was expanded.\n     * @returns Returns `true` if invalid declaration found, else `false`.\n     */\n    function lintDeclStrictValue(\n      node: Declaration,\n      longhandProp?: string,\n      longhandValue?: string,\n      isExpanded = false\n    ) {\n      const { value: nodeValue, prop: nodeProp } = node;\n      const value = longhandValue || nodeValue;\n\n      // falsify everything by default\n      let validVar = false;\n      let validFunc = false;\n      let validKeyword = false;\n      let validValue = false;\n\n      // test variable\n      if (ignoreVariables) {\n        // @TODO: deviant regexes to primary options need to be evaluated\n        const ignoreVariable = getIgnoredVariablesOrFunctions(\n          ignoreVariables,\n          property\n        );\n\n        if (ignoreVariable) {\n          validVar = reVar.test(value) || cssLoaderValues.test(value);\n        }\n      }\n\n      // test function\n      if (ignoreFunctions && !validVar) {\n        // @TODO: deviant regexes to primary options need to be evaluated\n        const ignoreFunction = getIgnoredVariablesOrFunctions(\n          ignoreFunctions,\n          property\n        );\n\n        if (ignoreFunction) {\n          validFunc = reFunc.test(value);\n        }\n      }\n\n      // test expanded shorthands are valid\n      if (\n        isExpanded &&\n        ignoreVariables &&\n        !validVar &&\n        ignoreFunctions &&\n        !validFunc &&\n        cssValues(longhandProp, longhandValue) !== true\n      ) {\n        return false;\n      }\n\n      // test keywords\n      if (ignoreKeywords && (!validVar || !validFunc)) {\n        let reKeyword = reKeywords![property];\n\n        if (!reKeyword) {\n          const ignoreKeyword = getIgnoredKeywords(ignoreKeywords, property);\n\n          if (ignoreKeyword) {\n            reKeyword = new RegExp(`^${ignoreKeyword.join('$|^')}$`);\n            reKeywords![property] = reKeyword;\n          }\n        }\n\n        if (reKeyword) {\n          validKeyword = reKeyword.test(value);\n        }\n      }\n\n      if (ignoreValues && (!validVar || !validFunc || !validKeyword)) {\n        let reValueList = reValues![property];\n\n        if (!reValueList) {\n          const ignoreValue = getIgnoredValues(ignoreValues, property);\n\n          if (ignoreValue) {\n            reValueList = ignoreValue.map(mapIgnoreValue);\n            reValues![property] = reValueList;\n          }\n        }\n\n        if (reValueList) {\n          validValue =\n            reValueList.filter((reValue) => reValue.test(value)).length > 0;\n        }\n      }\n\n      // report only if all failed\n      if (!validVar && !validFunc && !validKeyword && !validValue) {\n        const types = getTypes(config, property);\n\n        // support auto fixing\n        if (context.fix && !disableFix) {\n          const fixedValue = autoFixFuncNormalized!(\n            node,\n            {\n              validVar,\n              validFunc,\n              validKeyword,\n              validValue,\n              longhandProp,\n              longhandValue,\n            },\n            root,\n            config\n          );\n\n          // apply fixed value if returned\n          if (fixedValue) {\n            // eslint-disable-next-line no-param-reassign\n            node.value = fixedValue;\n          }\n        } else {\n          const { raws } = node;\n          // eslint-disable-next-line prefer-destructuring\n          const start = node.source!.start;\n\n          utils.report({\n            ruleName,\n            result,\n            node,\n            line: start!.line,\n            // column: start!.column + nodeProp.length + raws.between!.length,\n            message: messages.expected(types, value, nodeProp, message),\n          });\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n  });\n};\n\nruleFunction.primaryOptionArray = true;\n\nconst declarationStrictValuePlugin = stylelint.createPlugin(\n  ruleName,\n  ruleFunction\n);\n\nexport default declarationStrictValuePlugin;\nexport { ruleName, messages };\n"],"names":["isIIgnoreValueHash","key","value","Object","hasOwnProperty","call","defaults","ignoreVariables","ignoreFunctions","ignoreKeywords","ignoreValues","expandShorthand","recurseLonghand","severity","message","undefined","disableFix","autoFixFunc","isNumberOrString","type","validProperties","actual","Array","isArray","every","item","validHash","keys","validBooleanHash","validOptions","allowedKeys","indexOf","getIgnoredVariablesOrFunctions","ignoreVariablesOrFunctions","property","getIgnoredKeywords","keywords","getIgnoredValues","values","ruleName","utils","stylelint","messages","ruleMessages","expected","types","customMessage","typesMessage","typesLast","pop","length","join","replace","reSkipProp","reVar","reFunc","reRegex","isRegexString","test","stringToRegex","match","slice","getRegexString","RegExp","mapIgnoreValue","ignoreValue","ruleFunction","properties","options","context","root","result","validateOptions","possible","optional","config","autoFixFuncNormalized","resolveAutoFixfunc","require","resolve","error","path","process","cwd","getAutoFixFunc","reKeywords","reValues","cssLoaderValues","cssLoaderValuesNames","walkAtRules","rule","name","params","split","trim","push","forEach","propFilter","lintDeclStrictValue","node","longhandProp","longhandValue","isExpanded","nodeProp","prop","validVar","validFunc","validKeyword","validValue","cssValues","reKeyword","ignoreKeyword","reValueList","map","filter","reValue","getTypes","fix","fixedValue","report","line","source","start","walkDecls","isShortHand","shortCSS","isShorthand","list","space","failedFlag","valueItem","expandedProps","expand","primaryOptionArray","declarationStrictValuePlugin","createPlugin"],"mappings":"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"}