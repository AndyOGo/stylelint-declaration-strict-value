{"version":3,"file":"index.esm.js","sources":["../src/defaults.ts","../src/lib/validation.ts","../src/index.ts"],"sourcesContent":["import type { Node, Root } from 'stylelint/node_modules/postcss';\n\n/**\n * Rule Name.\n */\nexport const ruleName = 'scale-unlimited/declaration-strict-value';\n\n/**\n * A hash of CSS properties to ignore variables or functions.\n */\nexport interface IgnoreVariableOrFunctionHash {\n  [key: string]: boolean;\n}\n/**\n * Possible config for `ignoreVariables` and `ignoreFunctions` option.\n */\nexport type IgnoreVariableOrFunctionConfig =\n  | boolean\n  | IgnoreVariableOrFunctionHash;\n/**\n * A Regular Expression string to match a CSS property or value.\n */\nexport type RegExpString = string;\n/**\n * A CSS value to be ignored.\n */\nexport type IgnoreValue = number | string | RegExpString;\n/**\n * A list of CSS values to be ignored.\n */\nexport type IgnoreValueList = Array<IgnoreValue>;\n/**\n * A hash of CSS properties with ignored values.\n * - `''` key applies to all configured CSS properties.\n * - key can also be a Regular Expression string.\n */\nexport interface IgnoreValueHash {\n  '': IgnoreValue | IgnoreValueList;\n  [CSSPropertyName: string]: IgnoreValue | IgnoreValueList;\n  // [CSSPropertyName: TRegExpString]: TIgnoreValue | TIgnoreValueList;\n}\n/**\n * @internal\n */\nexport const isIIgnoreValueHash = (\n  key: unknown,\n  value: unknown\n): key is IgnoreValueHash =>\n  typeof key === 'object' && Object.hasOwnProperty.call(key, value);\n/**\n * Possible config for `ignoreValues` and ~~`ignoreKeywords`~~ option.\n */\nexport type IgnoreValueConfig =\n  | null\n  | IgnoreValue\n  | IgnoreValueList\n  | IgnoreValueHash;\n/**\n * Result of CSS value validation.\n */\nexport interface DeclarationStrictValueResult {\n  /**\n   * Whether or not variable is valid.\n   */\n  validVar: boolean;\n\n  /**\n   * Whether or not function is valid.\n   */\n  validFunc: boolean;\n\n  /**\n   * Whether or not keyword is valid.\n   */\n  validKeyword: boolean;\n\n  /**\n   * Whether or not value is valid.\n   */\n  validValue: boolean;\n\n  /**\n   * Longhand CSS Property, if expanded.\n   */\n  longhandProp?: string;\n\n  /**\n   * Longhand CSS value, if expanded.\n   */\n  longhandValue?: string;\n}\n/**\n * A autofix function.\n */\nexport type AutoFixFunc = (\n  node: Node,\n  result: DeclarationStrictValueResult,\n  root: Root,\n  config: SecondaryOptions\n) => string;\n/**\n * Path to autofix function module.\n */\nexport type AutoFixModule = string;\n/**\n * Possible config for `autoFixFunc` option.\n */\nexport type AutoFixFuncConfig = null | undefined | AutoFixModule | AutoFixFunc;\n\n/**\n * Plugin secondary options.\n */\nexport interface SecondaryOptions {\n  /**\n   * Whether or not to ignore variables.\n   *\n   * @defaultValue true\n   */\n  ignoreVariables?: IgnoreVariableOrFunctionConfig;\n\n  /**\n   * Whether or not to ignore function.\n   *\n   * @defaultValue true\n   */\n  ignoreFunctions?: IgnoreVariableOrFunctionConfig;\n\n  /**\n   * An ignored keywords config.\n   *\n   * @defaultValue null\n   * @deprecated use `ignoreValues` option.\n   */\n  ignoreKeywords?: IgnoreValueConfig;\n\n  /**\n   * An ignored values config.\n   *\n   * @defaultValue null\n   */\n  ignoreValues?: IgnoreValueConfig;\n\n  /**\n   * Whether or not to expand shorthand CSS properties.\n   *\n   * @defaultValue false\n   */\n  expandShorthand?: boolean;\n\n  /**\n   * Whether or not to expand longhand CSS properties recursivly - this is only useful for the `border` property.\n   *\n   * @defaultValue false\n   */\n  recurseLonghand?: boolean;\n\n  /**\n   * Adjust severity of the rule, `'warning'` or `'error'` (default).\n   *\n   * @defaultValue 'error'\n   */\n  severity?: string;\n\n  /**\n   * A custom message when a rule is violated, interpolated with `${types}`, `${value}` and `${property}`.\n   *\n   * @defaultValue undefined\n   */\n  message?: string;\n\n  /**\n   * Don't auto-fix if `--fix` option is applied.\n   *\n   * @defaultValue false\n   */\n  disableFix?: boolean;\n\n  /**\n   * By default no auto-fix feature.\n   *\n   * @defaultValue null\n   */\n  autoFixFunc?: AutoFixFuncConfig;\n}\n\nconst defaults: SecondaryOptions = {\n  ignoreVariables: true,\n  ignoreFunctions: true,\n  ignoreKeywords: null,\n  ignoreValues: null,\n  expandShorthand: false,\n  recurseLonghand: false,\n  severity: 'error',\n  message: undefined,\n  disableFix: false,\n  autoFixFunc: null,\n};\n\nexport default defaults;\n","import path from 'path';\n\nimport defaults, {\n  ruleName,\n  SecondaryOptions,\n  IgnoreValue,\n  IgnoreValueList,\n  IgnoreValueHash,\n  IgnoreVariableOrFunctionConfig,\n  IgnoreVariableOrFunctionHash,\n  IgnoreValueConfig,\n  AutoFixFunc,\n  AutoFixFuncConfig,\n  isIIgnoreValueHash,\n} from '../defaults';\n\n/**\n * Check if type is either `number` or `string`.\n *\n * @internal\n * @param value - Any value.\n *\n * @returns Returns `true` if `value`'s type is either `number` or `string`, else `false`.\n */\nfunction isNumberOrString(value: unknown): value is IgnoreValue {\n  const type = typeof value;\n\n  return type === 'string' || type === 'number';\n}\n\n/**\n * Validate primary options of stylelint plugin config.\n *\n * @internal\n * @param actual - The actual config to validate.\n *\n * @returns Returns `true` if primary options are valid, else `false`.\n */\nexport function validProperties(\n  actual: unknown\n): actual is IgnoreValue | IgnoreValueList {\n  return (\n    isNumberOrString(actual) ||\n    (Array.isArray(actual) && actual.every((item) => isNumberOrString(item)))\n  );\n}\n\n/**\n * Validate optional hash keyword config.\n *\n * @internal\n * @param actual - A keyword config.\n *\n * @returns Returns `true` if hash keyword config is valid, else `false`.\n */\nfunction validHash(actual: unknown): actual is IgnoreValueHash {\n  if (typeof actual !== 'object' || !actual) return false;\n\n  return Object.keys(actual).every((key) =>\n    validProperties((actual as IgnoreValueHash)[key as keyof IgnoreValueHash])\n  );\n}\n\n/**\n * Validate optional boolean hash variable/function config.\n *\n * @internal\n * @param actual - A variable/function config.\n *\n * @returns Returns `true` if hash variable/function config is valid, else `false`.\n */\nfunction validBooleanHash(\n  actual: unknown\n): actual is IgnoreVariableOrFunctionHash {\n  if (typeof actual !== 'object' || !actual) return false;\n\n  return Object.keys(actual).every(\n    (key) =>\n      typeof (actual as IgnoreVariableOrFunctionHash)[\n        key as keyof IgnoreVariableOrFunctionHash\n      ] === 'boolean'\n  );\n}\n\n/**\n * Validate optional secondary options of stylelint plugin config.\n *\n * @internal\n * @param actual - The actual config to validate.\n *\n * @returns Returns `true` if secondary options are valid, else `false`.\n */\nexport function validOptions(actual: SecondaryOptions): boolean {\n  if (typeof actual !== 'object') return false;\n\n  const allowedKeys = Object.keys(defaults);\n  if (!Object.keys(actual).every((key) => allowedKeys.indexOf(key) > -1))\n    return false;\n\n  if (\n    'ignoreVariables' in actual &&\n    typeof actual.ignoreVariables !== 'boolean' &&\n    !validBooleanHash(actual.ignoreVariables) &&\n    actual.ignoreVariables !== null\n  )\n    return false;\n\n  if (\n    'ignoreFunctions' in actual &&\n    typeof actual.ignoreFunctions !== 'boolean' &&\n    !validBooleanHash(actual.ignoreFunctions) &&\n    actual.ignoreFunctions !== null\n  )\n    return false;\n\n  if (\n    'severity' in actual &&\n    typeof actual.severity !== 'string' &&\n    actual.severity !== null\n  )\n    return false;\n\n  if (\n    'ignoreKeywords' in actual &&\n    !validProperties(actual.ignoreKeywords) &&\n    !validHash(actual.ignoreKeywords)\n  )\n    return false;\n\n  if (\n    'ignoreValues' in actual &&\n    !validProperties(actual.ignoreValues) &&\n    !validHash(actual.ignoreValues)\n  )\n    return false;\n\n  if (\n    'expandShorthand' in actual &&\n    typeof actual.expandShorthand !== 'boolean' &&\n    actual.expandShorthand !== null\n  )\n    return false;\n\n  if (\n    'recurseLonghand' in actual &&\n    typeof actual.recurseLonghand !== 'boolean' &&\n    actual.recurseLonghand !== null\n  )\n    return false;\n\n  if (\n    'message' in actual &&\n    typeof actual.message !== 'string' &&\n    actual.message !== null\n  )\n    return false;\n\n  if (\n    'disableFix' in actual &&\n    typeof actual.disableFix !== 'boolean' &&\n    actual.disableFix !== null\n  )\n    return false;\n\n  if (\n    'autoFixFunc' in actual &&\n    typeof actual.autoFixFunc !== 'function' &&\n    typeof actual.autoFixFunc !== 'string' &&\n    actual.autoFixFunc !== null\n  )\n    return false;\n\n  return true;\n}\n\n/**\n * Expected type of CSS value, available by configuration.\n * @internal\n */\ntype ExpectedType = 'variable' | 'function' | 'keyword';\n/**\n * Expected types of CSS value, as configured.\n * @internal\n */\ntype ExpectedTypes = Array<ExpectedType>;\n\n/**\n * Build expected message for stylelint report.\n *\n * @internal\n * @param types - Either `variable`, `function` and/or `keyword`.\n *\n * @returns Returns an expected types message for stylelint report.\n */\nexport function expectedTypes(types: ExpectedType | ExpectedTypes): string {\n  let typesMessage: string;\n\n  if (Array.isArray(types)) {\n    const typesLast = types.pop();\n\n    // eslint-disable-next-line no-param-reassign\n    typesMessage = types.length\n      ? `${types.join(', ')} or ${typesLast}`\n      : (typesLast as string);\n  } else {\n    typesMessage = types;\n  }\n\n  return typesMessage;\n}\n\n/**\n * Build expected message for stylelint report.\n *\n * @internal\n * @param typesMessage - An expected types message for stylelint report.\n * @param value - The CSS declaration's value.\n * @param property - The CSS declaration's property.\n *\n * @returns Returns an expected message for stylelint report.\n */\nexport function expected(\n  typesMessage: string,\n  value: string,\n  property: string\n): string {\n  return `Expected ${typesMessage} for \"${value}\" of \"${property}\"`;\n}\n\n/**\n * Build custom expected message for stylelint report.\n *\n * @internal\n * @param typesMessage - An expected types message for stylelint report.\n * @param value - The CSS declaration's value.\n * @param property - The CSS declaration's property.\n * @param customMessage - A custom message to be delivered upon error interpolated with `${types}`, `${value}` and `${property}`.\n *\n * @returns Returns a custom expected message for stylelint report.\n */\nexport function customExpected(\n  typesMessage: string,\n  value: string,\n  property: string,\n  customMessage: string\n): string {\n  /* eslint-disable no-template-curly-in-string */\n  return customMessage\n    .replace('${types}', typesMessage)\n    .replace('${value}', value)\n    .replace('${property}', property);\n  /* eslint-enable no-template-curly-in-string */\n}\n\n/**\n * Build failed-to-fix message for stylelint report.\n *\n * @internal\n * @param error - An expression to `throw`.\n * @param value - The CSS declaration's value.\n * @param property - The CSS declaration's property.\n *\n * @returns Returns an failed-to-fix message for stylelint report.\n */\nexport function failedToFix(\n  error: unknown,\n  value: string,\n  property: string\n): string {\n  if (error && (typeof error === 'string' || error instanceof Error)) {\n    return typeof error === 'string' ? error : error.message;\n  }\n\n  return `Property \"${property}\" with value \"${value}\" can't be autofixed`;\n}\n\n/**\n * Get configured types for stylelint report message.\n *\n * @internal\n * @param config - The secondary stylelint-plugin config.\n * @param property - The specific CSS declaration's property of the current iteration.\n *\n * @returns Returns a list of configured types.\n */\nexport function getTypes(\n  config: SecondaryOptions,\n  property: string\n): ExpectedTypes {\n  const { ignoreVariables, ignoreFunctions, ignoreKeywords, ignoreValues } =\n    config;\n  const types: ExpectedTypes = [];\n\n  if (ignoreVariables) {\n    types.push('variable');\n  }\n\n  if (ignoreFunctions) {\n    types.push('function');\n  }\n\n  if (ignoreKeywords && getIgnoredKeywords(ignoreKeywords, property)) {\n    types.push('keyword');\n  }\n\n  if (\n    types.indexOf('keyword') === -1 &&\n    ignoreValues &&\n    getIgnoredValues(ignoreValues, property)\n  ) {\n    types.push('keyword');\n  }\n\n  return types;\n}\n\n/**\n * Get the correct ignored variable or function for a specific CSS declaration's property\n * out of a complex `ignoreVariablesOrFunctions` config hash or boolean.\n *\n * @internal\n * @param ignoreVariablesOrFunctions - The variables or functions to ignore.\n * @param property - The specific CSS declaration's property of the current iteration.\n *\n * @returns Returns ignored variable or function for a specific CSS property.\n */\nexport function getIgnoredVariablesOrFunctions(\n  ignoreVariablesOrFunctions: IgnoreVariableOrFunctionConfig,\n  property: string\n): boolean {\n  // @see: https://github.com/microsoft/TypeScript/issues/41627\n  // const type = typeof ignoreVariablesOrFunctions\n\n  if (typeof ignoreVariablesOrFunctions === 'boolean') {\n    return ignoreVariablesOrFunctions;\n  }\n\n  if (\n    typeof ignoreVariablesOrFunctions === 'object' &&\n    ignoreVariablesOrFunctions &&\n    {}.hasOwnProperty.call(ignoreVariablesOrFunctions, property)\n  ) {\n    return ignoreVariablesOrFunctions[property];\n  }\n\n  return !!ignoreVariablesOrFunctions;\n}\n\n/**\n * Get the correct ignored keywords for a specific CSS declaration's property\n * out of a complex `ignoreKeywords` config hash or array.\n *\n * @internal\n * @param ignoreKeywords - The keyword/-s to ignore.\n * @param property - The specific CSS declaration's property of the current iteration.\n *\n * @returns Returns ignored keywords for a specific CSS property, or `null`.\n */\nexport function getIgnoredKeywords(\n  ignoreKeywords: IgnoreValueConfig,\n  property: string\n): null | IgnoreValueList {\n  if (!ignoreKeywords) return null;\n\n  let keywords = ignoreKeywords;\n\n  if (isIIgnoreValueHash(keywords, property)) {\n    keywords = keywords[property];\n  } else if (isIIgnoreValueHash(keywords, '')) {\n    keywords = keywords[''];\n  }\n\n  return Array.isArray(keywords) ? keywords : [keywords];\n}\n\n/**\n * Get the correct ignored values for a specific CSS declaration's property\n * out of a complex `ignoreValues` config hash or array.\n *\n * @internal\n * @param ignoreValues - The values/-s to ignore.\n * @param property - The specific CSS declaration's property of the current iteration.\n * @returns Returns ignored values for a specific CSS property, or `null`.\n */\nexport function getIgnoredValues(\n  ignoreValues: IgnoreValueConfig,\n  property: string\n): null | IgnoreValueList {\n  if (!ignoreValues) return null;\n\n  let values = ignoreValues;\n\n  if (isIIgnoreValueHash(values, property)) {\n    values = values[property];\n  } else if (isIIgnoreValueHash(values, '')) {\n    values = values[''];\n  }\n\n  return Array.isArray(values) ? values : [values];\n}\n\n/**\n * Get the auto-fix function either by a function directly or from a source file.\n *\n * @internal\n * @param autoFixFunc - A JavaScript function or a module path to resolve it, also from `cwd`.\n *\n * @returns Returns the auto-fix function if found, else `null`.\n */\nexport function getAutoFixFunc(\n  autoFixFunc: AutoFixFuncConfig,\n  disableFix?: boolean,\n  contextFix?: boolean\n): null | AutoFixFunc {\n  // @see: https://github.com/microsoft/TypeScript/issues/41627\n  // const type = typeof autoFixFunc\n\n  if (typeof autoFixFunc === 'function') {\n    return autoFixFunc;\n  }\n\n  if (typeof autoFixFunc === 'string') {\n    let resolveAutoFixfunc;\n\n    try {\n      resolveAutoFixfunc = require.resolve(autoFixFunc);\n    } catch (error) {\n      resolveAutoFixfunc = require.resolve(\n        path.join(process.cwd(), autoFixFunc)\n      );\n    }\n\n    // eslint-disable-next-line import/no-dynamic-require, global-require\n    return require(resolveAutoFixfunc);\n  }\n\n  if (!disableFix && contextFix) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      `No \\`autoFix\\` function provided, consider using \\`disableFix\\` for \"${ruleName}\"`\n    );\n  }\n\n  return null;\n}\n","import type { Declaration, Root, AtRule } from 'stylelint/node_modules/postcss';\nimport stylelint, { PostcssResult, Rule } from 'stylelint';\nimport shortCSS from 'shortcss';\nimport list from 'shortcss/lib/list';\nimport cssValues from 'css-values';\n\nimport {\n  validProperties,\n  validOptions,\n  expectedTypes,\n  customExpected,\n  expected,\n  getTypes,\n  getIgnoredVariablesOrFunctions,\n  getIgnoredKeywords,\n  getIgnoredValues,\n  getAutoFixFunc,\n  failedToFix,\n} from './lib/validation';\nimport defaults, {\n  ruleName,\n  SecondaryOptions,\n  IgnoreValue,\n  RegExpString,\n} from './defaults';\n\nconst { utils } = stylelint;\nconst messages = utils.ruleMessages(ruleName, {\n  expected,\n  customExpected,\n  failedToFix,\n});\n/**\n * RegExp to skip non-CSS properties.\n *\n * @internal\n */\nconst reSkipProp = /^(?:@|\\$|--).+$/;\n/**\n * RegExp to parse CSS, SCSS and less variables.\n * - allowing CSS variables to be multi line\n * - Sass namespaces and CSS <ident-token> supported\n *\n * @internal\n * @see https://github.com/sass/sass/blob/master/accepted/module-system.md#member-references\n * @see  https://drafts.csswg.org/css-syntax-3/#ident-token-diagram\n */\n// eslint-disable-next-line no-control-regex\nconst reVar =\n  /^-?(?:@.+|(?:(?:[a-zA-Z_-]|[^\\x20-\\x7F])+(?:[a-zA-Z0-9_-]|[^\\x20-\\x7F])*\\.)?\\$.+|var\\(\\s*--[\\s\\S]+\\))$/;\n/**\n * RegExp to parse functions.\n * - irgnoring CSS variables `var(--*)`\n * - allow multi line arguments\n *\n * @internal\n */\nconst reFunc = /^(?!var\\(\\s*--)[\\s\\S]+\\([\\s\\S]*\\)$/;\n/**\n * RegExp to parse regular expressions.\n * - supporting patterns\n * - and optional flags\n *\n * @internal\n */\nconst reRegex = /^\\/(.*)\\/([a-zA-Z]*)$/;\n/**\n * @internal\n */\nconst reColorProp = /color/;\ntype RegExpArray = [string, string?];\n/**\n * Checks if string is a Regular Expression.\n *\n * @internal\n * @param value - Any string.\n */\nconst checkCssValue = (prop: string, value: string) =>\n  (reColorProp.test(prop) && value === 'transparent') ||\n  reVar.test(value) ||\n  reFunc.test(value) ||\n  cssValues(prop, value);\nconst isRegexString = (value: string): value is RegExpString =>\n  reRegex.test(value);\n/**\n * Get pattern and flags of a Regular Expression string.\n *\n * @internal\n * @param value - Any string representing a Regular Expression.\n * @returns An Array of pattern and flags of a Regular Expression string.\n */\nconst getRegexString = (value: string): RegExpArray =>\n  value.match(reRegex)!.slice(1) as RegExpArray;\n/**\n * Convert a Regular Expression string to an RegExp object.\n *\n * @internal\n * @param value - Any string representing a Regular Expression.\n * @returns A Regular Expression object.\n */\nconst stringToRegex = (value: RegExpString) => {\n  const [pattern, flags] = getRegexString(value);\n  return new RegExp(pattern, flags);\n};\n/**\n * Map ignored value config to a Regular expression.\n *\n * @internal\n * @param ignoreValue - A ignored value property.\n * @returns A Regular Expression to match ignored values.\n */\nconst mapIgnoreValue = (ignoreValue: IgnoreValue) =>\n  isRegexString(`${ignoreValue}`)\n    ? stringToRegex(`${ignoreValue}`)\n    : new RegExp(`^${ignoreValue}$`);\n\n/**\n * A string or regular expression matching a CSS property name.\n */\ntype CSSPropertyName = string | RegExpString;\n\n/**\n * Primary options, a CSS property or list of CSS properties to lint.\n * - Regular Expression strings are supported\n */\ntype PrimaryOptions = CSSPropertyName | CSSPropertyName[];\n\ntype RuleContext = {\n  fix?: boolean | undefined;\n  newline?: string | undefined;\n};\n\n/**\n * Stylelint declaration strict value rule function.\n *\n * @see https://stylelint.io/developer-guide/plugins\n * @param properties - Primary options, a CSS property or list of CSS properties to lint.\n * @param options- Secondary options, configure edge cases.\n * @param context - Only used for autofixing.\n *\n * @returns Returns a PostCSS Plugin.\n */\ntype StylelintPlugin<P = unknown, S = unknown> = Rule<P, S>;\n\nconst ruleFunction: StylelintPlugin<PrimaryOptions, SecondaryOptions> =\n  (\n    properties: PrimaryOptions,\n    options: SecondaryOptions,\n    context: RuleContext = {}\n  ) =>\n  (root: Root, result: PostcssResult) => {\n    // fix #142\n    // @see https://github.com/stylelint/stylelint/pull/672/files#diff-78f1c80ffb2836008dd194b3b0ca28f9b46e4897b606f0b3d25a29e57a8d3e61R74\n    // @see https://stylelint.io/user-guide/configure#message\n    /* eslint-disable @typescript-eslint/no-explicit-any */\n    if (\n      result &&\n      (result as any).stylelint &&\n      (result as any).stylelint.customMessages &&\n      (result as any).stylelint.customMessages[ruleName]\n    ) {\n      // eslint-disable-next-line no-param-reassign\n      delete (result as any).stylelint.customMessages[ruleName];\n    }\n    /* eslint-enable @typescript-eslint/no-explicit-any */\n\n    // validate stylelint plugin options\n    const hasValidOptions = utils.validateOptions(\n      result,\n      ruleName,\n      {\n        actual: properties,\n        possible: validProperties,\n      },\n      {\n        actual: options,\n        possible: validOptions,\n        optional: true,\n      }\n    );\n\n    if (!hasValidOptions) return;\n\n    // normalize options\n    if (!Array.isArray(properties)) {\n      // eslint-disable-next-line no-param-reassign\n      properties = [properties];\n    }\n\n    const config: SecondaryOptions = {\n      ...defaults,\n      ...options,\n    };\n    const {\n      ignoreVariables,\n      ignoreFunctions,\n      ignoreKeywords,\n      ignoreValues,\n      message,\n      disableFix,\n      autoFixFunc,\n      expandShorthand,\n      recurseLonghand,\n    } = config;\n    const autoFixFuncNormalized = getAutoFixFunc(\n      autoFixFunc,\n      disableFix,\n      context.fix\n    );\n    /**\n     * A hash of regular expression to ignore for a CSS properties.\n     * @internal\n     */\n    interface RegExpMap {\n      // [key: CSSPropertyName]: RegExp;\n      [key: string]: RegExp;\n    }\n    /**\n     * A hash of regular expression to ignore for a CSS properties or `null`.\n     * @internal\n     */\n    type RegExpKeywordMap = null | RegExpMap;\n    /**\n     * A hash of regular expression lists to ignore for a CSS property.\n     * @internal\n     */\n    interface RegExpList {\n      // [key: CSSPropertyName]: RegExp[];\n      [key: string]: RegExp[];\n    }\n    /**\n     * A hash of regular expression lists to ignore for a CSS property or `null`.\n     * @internal\n     */\n    type RegExpValuesList = null | RegExpList;\n    const reKeywords: RegExpKeywordMap = ignoreKeywords ? {} : null;\n    const reValues: RegExpValuesList = ignoreValues ? {} : null;\n    let cssLoaderValues: RegExp;\n\n    if (ignoreVariables) {\n      const cssLoaderValuesNames: string[] = [];\n      root.walkAtRules('value', (rule: AtRule) => {\n        const { params } = rule;\n        const name = params.split(':')[0].trim();\n\n        cssLoaderValuesNames.push(name);\n      });\n\n      cssLoaderValues = new RegExp(`^-?(:?${cssLoaderValuesNames.join('|')})$`);\n    }\n\n    // loop through all properties\n    properties.forEach((property) => {\n      let propFilter: string | RegExp = property;\n\n      // parse RegExp\n      if (isRegexString(propFilter)) {\n        propFilter = stringToRegex(propFilter);\n      }\n\n      // walk through all declarations filtered by configured properties\n      root.walkDecls(filterDecl);\n\n      /**\n       * Filter declarations for matching properties and expand shorthand properties.\n       *\n       * @internal\n       * @param node - A Declaration-Node from PostCSS AST-Parser.\n       */\n      function filterDecl(node: Declaration) {\n        const { value, prop } = node;\n\n        // skip variable declarations\n        if (reSkipProp.test(prop)) return;\n\n        const isShortHand = expandShorthand && shortCSS.isShorthand(prop);\n\n        if (\n          prop === propFilter ||\n          (!isShortHand &&\n            propFilter instanceof RegExp &&\n            propFilter.test(prop))\n        ) {\n          const values: string[] = list.space(value);\n\n          // handle multi-value props, like scrollbar-color\n          if (values.length > 1) {\n            let failedFlag = false;\n\n            values.forEach((valueItem) => {\n              if (!failedFlag) {\n                failedFlag = lintDeclStrictValue(node, prop, valueItem);\n              }\n            });\n          } else {\n            lintDeclStrictValue(node);\n          }\n        } else if (isShortHand) {\n          const expandedProps = shortCSS.expand(prop, value, recurseLonghand);\n          let failedFlag = false;\n\n          Object.keys(expandedProps).forEach((longhandProp) => {\n            const longhandValue = expandedProps[longhandProp];\n\n            if (\n              !failedFlag &&\n              (longhandProp === propFilter ||\n                (propFilter instanceof RegExp && propFilter.test(longhandProp)))\n            ) {\n              failedFlag = lintDeclStrictValue(\n                node,\n                longhandProp,\n                longhandValue,\n                true\n              );\n            }\n          });\n        }\n      }\n\n      /**\n       * Lint usages of declarations values against, variables, functions\n       * or custom keywords - as configured.\n       *\n       * @internal\n       * @param node - A Declaration-Node from PostCSS AST-Parser.\n       * @param longhandProp - A Declaration-Node from PostCSS AST-Parser.\n       * @param longhandValue - A Declaration-Node from PostCSS AST-Parser.\n       * @param isExpanded - Whether or not this declaration was expanded.\n       * @returns Returns `true` if invalid declaration found, else `false`.\n       */\n      function lintDeclStrictValue(\n        node: Declaration,\n        longhandProp?: string,\n        longhandValue?: string,\n        isExpanded = false\n      ) {\n        const { value: nodeValue, prop: nodeProp } = node;\n        const value = longhandValue || nodeValue;\n\n        // falsify everything by default\n        let validVar = false;\n        let validFunc = false;\n        let validKeyword = false;\n        let validValue = false;\n\n        // test variable\n        if (ignoreVariables) {\n          // @TODO: deviant regexes to primary options need to be evaluated\n          const ignoreVariable = getIgnoredVariablesOrFunctions(\n            ignoreVariables,\n            property\n          );\n\n          if (ignoreVariable) {\n            validVar = reVar.test(value) || cssLoaderValues.test(value);\n          }\n        }\n\n        // test function\n        if (ignoreFunctions && !validVar) {\n          // @TODO: deviant regexes to primary options need to be evaluated\n          const ignoreFunction = getIgnoredVariablesOrFunctions(\n            ignoreFunctions,\n            property\n          );\n\n          if (ignoreFunction) {\n            validFunc = reFunc.test(value);\n          }\n        }\n\n        // test expanded shorthands are valid\n        if (\n          isExpanded &&\n          (!ignoreVariables || (ignoreVariables && !validVar)) &&\n          (!ignoreFunctions || (ignoreFunctions && !validFunc)) &&\n          checkCssValue(longhandProp!, longhandValue!) !== true\n        ) {\n          return false;\n        }\n\n        // test keywords\n        if (ignoreKeywords && (!validVar || !validFunc)) {\n          let reKeyword = reKeywords![property];\n\n          if (!reKeyword) {\n            const ignoreKeyword = getIgnoredKeywords(ignoreKeywords, property);\n\n            if (ignoreKeyword) {\n              reKeyword = new RegExp(`^${ignoreKeyword.join('$|^')}$`);\n              reKeywords![property] = reKeyword;\n            }\n          }\n\n          if (reKeyword) {\n            validKeyword = reKeyword.test(value);\n          }\n        }\n\n        if (ignoreValues && (!validVar || !validFunc || !validKeyword)) {\n          let reValueList = reValues![property];\n\n          if (!reValueList) {\n            const ignoreValue = getIgnoredValues(ignoreValues, property);\n\n            if (ignoreValue) {\n              reValueList = ignoreValue.map(mapIgnoreValue);\n              reValues![property] = reValueList;\n            }\n          }\n\n          if (reValueList) {\n            validValue =\n              reValueList.filter((reValue) => reValue.test(value)).length > 0;\n          }\n        }\n\n        // report only if all failed\n        if (!validVar && !validFunc && !validKeyword && !validValue) {\n          const types = getTypes(config, property);\n\n          // support auto fixing\n          if (context.fix && !disableFix && autoFixFuncNormalized) {\n            try {\n              const fixedValue = autoFixFuncNormalized(\n                node,\n                {\n                  validVar,\n                  validFunc,\n                  validKeyword,\n                  validValue,\n                  longhandProp,\n                  longhandValue,\n                },\n                root,\n                config\n              );\n\n              // apply fixed value if returned\n              if (fixedValue) {\n                // eslint-disable-next-line no-param-reassign\n                node.value = fixedValue;\n              }\n            } catch (error) {\n              const { raws } = node;\n              // eslint-disable-next-line prefer-destructuring\n              const start = node.source!.start;\n\n              utils.report({\n                ruleName,\n                result,\n                node,\n                line: start!.line,\n                column: start!.column + nodeProp.length + raws.between!.length,\n                message: messages.failedToFix(error, value, nodeProp),\n              } as any);\n            }\n          } else {\n            const { raws } = node;\n            // eslint-disable-next-line prefer-destructuring\n            const start = node.source!.start;\n\n            utils.report({\n              ruleName,\n              result,\n              node,\n              line: start!.line,\n              column: start!.column + nodeProp.length + raws.between!.length,\n              message: message\n                ? messages.customExpected(\n                    expectedTypes(types),\n                    value,\n                    nodeProp,\n                    message\n                  )\n                : messages.expected(expectedTypes(types), value, nodeProp),\n            } as any);\n          }\n\n          return true;\n        }\n\n        return false;\n      }\n    });\n  };\n\nruleFunction.primaryOptionArray = true;\nruleFunction.ruleName = ruleName;\nruleFunction.messages = messages;\n\nconst declarationStrictValuePlugin = stylelint.createPlugin(\n  ruleName,\n  ruleFunction\n);\n\nexport default declarationStrictValuePlugin;\nexport { ruleName, messages };\n"],"names":["ruleName","key","value","Object","hasOwnProperty","call","ignoreVariables","ignoreFunctions","ignoreKeywords","ignoreValues","expandShorthand","recurseLonghand","severity","message","undefined","disableFix","autoFixFunc","type","actual","Array","isArray","every","item","isNumberOrString","keys","validProperties","defaults","allowedKeys","indexOf","validBooleanHash","validHash","types","pop","typesMessage","length","join","typesLast","ignoreVariablesOrFunctions","property","isIIgnoreValueHash","keywords","values","utils","stylelint","ruleMessages","expected","customExpected","customMessage","replace","failedToFix","error","reRegex","test","pattern","flags","match","slice","getRegexString","ignoreValue","isRegexString","stringToRegex","properties","options","context","root","result","customMessages","validateOptions","possible","validOptions","optional","config","contextFix","resolveAutoFixfunc","require","resolve","path","process","cwd","console","warn","getAutoFixFunc","fix","walkAtRules","rule","params","split","trim","cssLoaderValuesNames","push","name","cssLoaderValues","forEach","node","longhandProp","longhandValue","isExpanded","nodeValue","prop","nodeProp","getIgnoredVariablesOrFunctions","validVar","reVar","validFunc","reFunc","reColorProp","cssValues","checkCssValue","reKeywords","reKeyword","getIgnoredKeywords","ignoreKeyword","validKeyword","reValues","reValueList","getIgnoredValues","map","mapIgnoreValue","validValue","filter","reValue","getTypes","autoFixFuncNormalized","fixedValue","raws","source","start","report","line","column","between","messages","expectedTypes","propFilter","walkDecls","reSkipProp","shortCSS","isShorthand","isShortHand","list","space","valueItem","failedFlag","lintDeclStrictValue","expand","expandedProps","ruleFunction","primaryOptionArray","createPlugin"],"mappings":"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"}